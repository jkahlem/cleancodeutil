/**
* THE CODE OF THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD NOT BE EDITED MANUALLY.
*/
package csv

import (
	"reflect"
	"returntypes-langserver/common/log"
)
func (t Method) ToRecordTEST() []string {
	if record, err := marshal(reflect.ValueOf(t)); err != nil {
		log.Error(err)
		log.ReportProblem("An error occured while marshalling data")
		return nil
	} else {
		return record
	}
}

func UnmarshalMethodTEST(records [][]string) []Method {
	typ := reflect.TypeOf(Method{})
	result := make([]Method, 0, len(records))
	for _, record := range records {
		if unmarshalled, err := unmarshal(record,  typ); err != nil {
			log.Error(err)
			log.ReportProblem("An error occured while unmarshalling data")
		} else if c, ok := (unmarshalled.Interface()).(Method); ok {
			result = append(result, c)
		}
	}
	return result
}

func (t Class) ToRecordTEST() []string {
	if record, err := marshal(reflect.ValueOf(t)); err != nil {
		log.Error(err)
		log.ReportProblem("An error occured while marshalling data")
		return nil
	} else {
		return record
	}
}

func UnmarshalClassTEST(records [][]string) []Class {
	typ := reflect.TypeOf(Class{})
	result := make([]Class, 0, len(records))
	for _, record := range records {
		if unmarshalled, err := unmarshal(record,  typ); err != nil {
			log.Error(err)
			log.ReportProblem("An error occured while unmarshalling data")
		} else if c, ok := (unmarshalled.Interface()).(Class); ok {
			result = append(result, c)
		}
	}
	return result
}

func (t TypeConversion) ToRecordTEST() []string {
	if record, err := marshal(reflect.ValueOf(t)); err != nil {
		log.Error(err)
		log.ReportProblem("An error occured while marshalling data")
		return nil
	} else {
		return record
	}
}

func UnmarshalTypeConversionTEST(records [][]string) []TypeConversion {
	typ := reflect.TypeOf(TypeConversion{})
	result := make([]TypeConversion, 0, len(records))
	for _, record := range records {
		if unmarshalled, err := unmarshal(record,  typ); err != nil {
			log.Error(err)
			log.ReportProblem("An error occured while unmarshalling data")
		} else if c, ok := (unmarshalled.Interface()).(TypeConversion); ok {
			result = append(result, c)
		}
	}
	return result
}

func (t DatasetRow) ToRecordTEST() []string {
	if record, err := marshal(reflect.ValueOf(t)); err != nil {
		log.Error(err)
		log.ReportProblem("An error occured while marshalling data")
		return nil
	} else {
		return record
	}
}

func UnmarshalDatasetRowTEST(records [][]string) []DatasetRow {
	typ := reflect.TypeOf(DatasetRow{})
	result := make([]DatasetRow, 0, len(records))
	for _, record := range records {
		if unmarshalled, err := unmarshal(record,  typ); err != nil {
			log.Error(err)
			log.ReportProblem("An error occured while unmarshalling data")
		} else if c, ok := (unmarshalled.Interface()).(DatasetRow); ok {
			result = append(result, c)
		}
	}
	return result
}

func (t DatasetRow2) ToRecordTEST() []string {
	if record, err := marshal(reflect.ValueOf(t)); err != nil {
		log.Error(err)
		log.ReportProblem("An error occured while marshalling data")
		return nil
	} else {
		return record
	}
}

func UnmarshalDatasetRow2TEST(records [][]string) []DatasetRow2 {
	typ := reflect.TypeOf(DatasetRow2{})
	result := make([]DatasetRow2, 0, len(records))
	for _, record := range records {
		if unmarshalled, err := unmarshal(record,  typ); err != nil {
			log.Error(err)
			log.ReportProblem("An error occured while unmarshalling data")
		} else if c, ok := (unmarshalled.Interface()).(DatasetRow2); ok {
			result = append(result, c)
		}
	}
	return result
}

func (t TypeLabel) ToRecordTEST() []string {
	if record, err := marshal(reflect.ValueOf(t)); err != nil {
		log.Error(err)
		log.ReportProblem("An error occured while marshalling data")
		return nil
	} else {
		return record
	}
}

func UnmarshalTypeLabelTEST(records [][]string) []TypeLabel {
	typ := reflect.TypeOf(TypeLabel{})
	result := make([]TypeLabel, 0, len(records))
	for _, record := range records {
		if unmarshalled, err := unmarshal(record,  typ); err != nil {
			log.Error(err)
			log.ReportProblem("An error occured while unmarshalling data")
		} else if c, ok := (unmarshalled.Interface()).(TypeLabel); ok {
			result = append(result, c)
		}
	}
	return result
}
