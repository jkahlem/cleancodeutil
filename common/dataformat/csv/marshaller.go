/**
* THE CODE OF THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD NOT BE EDITED MANUALLY.
 */
package csv

import (
	"fmt"
	"returntypes-langserver/common/debug/errors"
	"returntypes-langserver/common/debug/log"
	"strconv"
)

func UnmarshalMethod(records [][]string) []Method {
	result := make([]Method, len(records))
	for i, record := range records {
		result[i].ClassName = record[i]
		result[i].ReturnType = record[i]
		result[i].MethodName = record[i]
		result[i].Parameters = SplitList(record[i])
		result[i].Labels = SplitList(record[i])
		result[i].Modifier = SplitList(record[i])
		result[i].ClassField = record[i]
		result[i].FilePath = record[i]
	}
	return result
}

func (s Method) ToRecord() []string {
	record := make([]string, 8)
	record[0] = s.ClassName
	record[1] = s.ReturnType
	record[2] = s.MethodName
	record[3] = MakeList(s.Parameters)
	record[4] = MakeList(s.Labels)
	record[5] = MakeList(s.Modifier)
	record[6] = s.ClassField
	record[7] = s.FilePath
	return record
}

func MarshalMethod(records []Method) [][]string {
	result := make([][]string, len(records))
	for i := range records {
		result[i] = records[i].ToRecord()
	}
	return result
}
func UnmarshalClass(records [][]string) []Class {
	result := make([]Class, len(records))
	for i, record := range records {
		result[i].ClassName = record[i]
		result[i].Extends = SplitList(record[i])
	}
	return result
}

func (s Class) ToRecord() []string {
	record := make([]string, 2)
	record[0] = s.ClassName
	record[1] = MakeList(s.Extends)
	return record
}

func MarshalClass(records []Class) [][]string {
	result := make([][]string, len(records))
	for i := range records {
		result[i] = records[i].ToRecord()
	}
	return result
}
func UnmarshalTypeConversion(records [][]string) []TypeConversion {
	result := make([]TypeConversion, len(records))
	for i, record := range records {
		result[i].SourceType = record[i]
		result[i].DestinationType = record[i]
	}
	return result
}

func (s TypeConversion) ToRecord() []string {
	record := make([]string, 2)
	record[0] = s.SourceType
	record[1] = s.DestinationType
	return record
}

func MarshalTypeConversion(records []TypeConversion) [][]string {
	result := make([][]string, len(records))
	for i := range records {
		result[i] = records[i].ToRecord()
	}
	return result
}
func UnmarshalReturnTypesDatasetRow(records [][]string) []ReturnTypesDatasetRow {
	result := make([]ReturnTypesDatasetRow, len(records))
	for i, record := range records {
		result[i].MethodName = record[i]
		if val, err := strconv.Atoi(record[i]); err != nil {
			log.Error(errors.Wrap(err, "Csv Error", "Could not convert int value"))
			log.ReportProblem("An error occured while unmarshalling data")
		} else {
			result[i].TypeLabel = val
		}
	}
	return result
}

func (s ReturnTypesDatasetRow) ToRecord() []string {
	record := make([]string, 2)
	record[0] = s.MethodName
	record[1] = fmt.Sprintf("%d", s.TypeLabel)
	return record
}

func MarshalReturnTypesDatasetRow(records []ReturnTypesDatasetRow) [][]string {
	result := make([][]string, len(records))
	for i := range records {
		result[i] = records[i].ToRecord()
	}
	return result
}
func UnmarshalMethodGenerationDatasetRow(records [][]string) []MethodGenerationDatasetRow {
	result := make([]MethodGenerationDatasetRow, len(records))
	for i, record := range records {
		result[i].ClassName = record[i]
		result[i].MethodName = record[i]
		result[i].Parameters = SplitList(record[i])
	}
	return result
}

func (s MethodGenerationDatasetRow) ToRecord() []string {
	record := make([]string, 3)
	record[0] = s.ClassName
	record[1] = s.MethodName
	record[2] = MakeList(s.Parameters)
	return record
}

func MarshalMethodGenerationDatasetRow(records []MethodGenerationDatasetRow) [][]string {
	result := make([][]string, len(records))
	for i := range records {
		result[i] = records[i].ToRecord()
	}
	return result
}
func UnmarshalTypeLabel(records [][]string) []TypeLabel {
	result := make([]TypeLabel, len(records))
	for i, record := range records {
		result[i].Name = record[i]
		if val, err := strconv.Atoi(record[i]); err != nil {
			log.Error(errors.Wrap(err, "Csv Error", "Could not convert int value"))
			log.ReportProblem("An error occured while unmarshalling data")
		} else {
			result[i].Label = val
		}
	}
	return result
}

func (s TypeLabel) ToRecord() []string {
	record := make([]string, 2)
	record[0] = s.Name
	record[1] = fmt.Sprintf("%d", s.Label)
	return record
}

func MarshalTypeLabel(records []TypeLabel) [][]string {
	result := make([][]string, len(records))
	for i := range records {
		result[i] = records[i].ToRecord()
	}
	return result
}
func UnmarshalIdealResult(records [][]string) []IdealResult {
	result := make([]IdealResult, len(records))
	for i, record := range records {
		result[i].FilePath = record[i]
		result[i].FileType = record[i]
		result[i].Identifier = record[i]
		result[i].IdentifierType = record[i]
		if val, err := strconv.Atoi(record[i]); err != nil {
			log.Error(errors.Wrap(err, "Csv Error", "Could not convert int value"))
			log.ReportProblem("An error occured while unmarshalling data")
		} else {
			result[i].LineNumber = val
		}
		if val, err := strconv.Atoi(record[i]); err != nil {
			log.Error(errors.Wrap(err, "Csv Error", "Could not convert int value"))
			log.ReportProblem("An error occured while unmarshalling data")
		} else {
			result[i].ColumnNumber = val
		}
		result[i].IssueID = record[i]
		result[i].IssueAdditionalDetail = record[i]
		result[i].IssueCategory = record[i]
		result[i].IssueDetail = record[i]
		result[i].AnalysisDateTime = record[i]
	}
	return result
}

func (s IdealResult) ToRecord() []string {
	record := make([]string, 11)
	record[0] = s.FilePath
	record[1] = s.FileType
	record[2] = s.Identifier
	record[3] = s.IdentifierType
	record[4] = fmt.Sprintf("%d", s.LineNumber)
	record[5] = fmt.Sprintf("%d", s.ColumnNumber)
	record[6] = s.IssueID
	record[7] = s.IssueAdditionalDetail
	record[8] = s.IssueCategory
	record[9] = s.IssueDetail
	record[10] = s.AnalysisDateTime
	return record
}

func MarshalIdealResult(records []IdealResult) [][]string {
	result := make([][]string, len(records))
	for i := range records {
		result[i] = records[i].ToRecord()
	}
	return result
}
