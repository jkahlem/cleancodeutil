/**
* THE CODE OF THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD NOT BE EDITED MANUALLY.
 */
package csv

import (
	"fmt"
	"returntypes-langserver/common/debug/errors"
	"returntypes-langserver/common/debug/log"
	"strconv"
)

func UnmarshalMethod(record []string) Method {
	result := Method{}
	result.ClassName = record[0]
	result.ReturnType = record[1]
	result.MethodName = record[2]
	result.Parameters = SplitList(record[3])
	result.Labels = SplitList(record[4])
	result.Modifier = SplitList(record[5])
	result.ClassField = record[6]
	result.FilePath = record[7]
	return result
}

func (s Method) ToRecord() []string {
	record := make([]string, 8)
	record[0] = s.ClassName
	record[1] = s.ReturnType
	record[2] = s.MethodName
	record[3] = MakeList(s.Parameters)
	record[4] = MakeList(s.Labels)
	record[5] = MakeList(s.Modifier)
	record[6] = s.ClassField
	record[7] = s.FilePath
	return record
}

func MarshalMethod(records []Method) [][]string {
	result := make([][]string, len(records))
	for i := range records {
		result[i] = records[i].ToRecord()
	}
	return result
}

func (r *Reader) ReadMethodRecords() ([]Method, errors.Error) {
	defer r.Close()
	rows := make([]Method, 0, 8)
	for {
		if record, err := r.ReadRecord(); err != nil {
			if err.Is(errors.EOF) {
				return rows, nil
			}
			return nil, err
		} else {
			rows = append(rows, UnmarshalMethod(record))
		}
	}
}

func (w *Writer) WriteMethodRecords(rows []Method) errors.Error {
	defer w.Close()
	for _, row := range rows {
		if err := w.WriteRecord(row.ToRecord()); err != nil {
			w.err = err
			return err
		}
	}
	return nil
}

func UnmarshalClass(record []string) Class {
	result := Class{}
	result.ClassName = record[0]
	result.Extends = SplitList(record[1])
	return result
}

func (s Class) ToRecord() []string {
	record := make([]string, 2)
	record[0] = s.ClassName
	record[1] = MakeList(s.Extends)
	return record
}

func MarshalClass(records []Class) [][]string {
	result := make([][]string, len(records))
	for i := range records {
		result[i] = records[i].ToRecord()
	}
	return result
}

func (r *Reader) ReadClassRecords() ([]Class, errors.Error) {
	defer r.Close()
	rows := make([]Class, 0, 8)
	for {
		if record, err := r.ReadRecord(); err != nil {
			if err.Is(errors.EOF) {
				return rows, nil
			}
			return nil, err
		} else {
			rows = append(rows, UnmarshalClass(record))
		}
	}
}

func (w *Writer) WriteClassRecords(rows []Class) errors.Error {
	defer w.Close()
	for _, row := range rows {
		if err := w.WriteRecord(row.ToRecord()); err != nil {
			w.err = err
			return err
		}
	}
	return nil
}

func UnmarshalTypeConversion(record []string) TypeConversion {
	result := TypeConversion{}
	result.SourceType = record[0]
	result.DestinationType = record[1]
	return result
}

func (s TypeConversion) ToRecord() []string {
	record := make([]string, 2)
	record[0] = s.SourceType
	record[1] = s.DestinationType
	return record
}

func MarshalTypeConversion(records []TypeConversion) [][]string {
	result := make([][]string, len(records))
	for i := range records {
		result[i] = records[i].ToRecord()
	}
	return result
}

func (r *Reader) ReadTypeConversionRecords() ([]TypeConversion, errors.Error) {
	defer r.Close()
	rows := make([]TypeConversion, 0, 8)
	for {
		if record, err := r.ReadRecord(); err != nil {
			if err.Is(errors.EOF) {
				return rows, nil
			}
			return nil, err
		} else {
			rows = append(rows, UnmarshalTypeConversion(record))
		}
	}
}

func (w *Writer) WriteTypeConversionRecords(rows []TypeConversion) errors.Error {
	defer w.Close()
	for _, row := range rows {
		if err := w.WriteRecord(row.ToRecord()); err != nil {
			w.err = err
			return err
		}
	}
	return nil
}

func UnmarshalReturnTypesDatasetRow(record []string) ReturnTypesDatasetRow {
	result := ReturnTypesDatasetRow{}
	result.MethodName = record[0]
	if val, err := strconv.Atoi(record[1]); err != nil {
		log.Error(errors.Wrap(err, "Csv Error", "Could not convert int value"))
		log.ReportProblem("An error occured while unmarshalling data")
	} else {
		result.TypeLabel = val
	}
	return result
}

func (s ReturnTypesDatasetRow) ToRecord() []string {
	record := make([]string, 2)
	record[0] = s.MethodName
	record[1] = fmt.Sprintf("%d", s.TypeLabel)
	return record
}

func MarshalReturnTypesDatasetRow(records []ReturnTypesDatasetRow) [][]string {
	result := make([][]string, len(records))
	for i := range records {
		result[i] = records[i].ToRecord()
	}
	return result
}

func (r *Reader) ReadReturnTypesDatasetRowRecords() ([]ReturnTypesDatasetRow, errors.Error) {
	defer r.Close()
	rows := make([]ReturnTypesDatasetRow, 0, 8)
	for {
		if record, err := r.ReadRecord(); err != nil {
			if err.Is(errors.EOF) {
				return rows, nil
			}
			return nil, err
		} else {
			rows = append(rows, UnmarshalReturnTypesDatasetRow(record))
		}
	}
}

func (w *Writer) WriteReturnTypesDatasetRowRecords(rows []ReturnTypesDatasetRow) errors.Error {
	defer w.Close()
	for _, row := range rows {
		if err := w.WriteRecord(row.ToRecord()); err != nil {
			w.err = err
			return err
		}
	}
	return nil
}

func UnmarshalMethodGenerationDatasetRow(record []string) MethodGenerationDatasetRow {
	result := MethodGenerationDatasetRow{}
	result.ClassName = record[0]
	result.MethodName = record[1]
	result.Parameters = SplitList(record[2])
	return result
}

func (s MethodGenerationDatasetRow) ToRecord() []string {
	record := make([]string, 3)
	record[0] = s.ClassName
	record[1] = s.MethodName
	record[2] = MakeList(s.Parameters)
	return record
}

func MarshalMethodGenerationDatasetRow(records []MethodGenerationDatasetRow) [][]string {
	result := make([][]string, len(records))
	for i := range records {
		result[i] = records[i].ToRecord()
	}
	return result
}

func (r *Reader) ReadMethodGenerationDatasetRowRecords() ([]MethodGenerationDatasetRow, errors.Error) {
	defer r.Close()
	rows := make([]MethodGenerationDatasetRow, 0, 8)
	for {
		if record, err := r.ReadRecord(); err != nil {
			if err.Is(errors.EOF) {
				return rows, nil
			}
			return nil, err
		} else {
			rows = append(rows, UnmarshalMethodGenerationDatasetRow(record))
		}
	}
}

func (w *Writer) WriteMethodGenerationDatasetRowRecords(rows []MethodGenerationDatasetRow) errors.Error {
	defer w.Close()
	for _, row := range rows {
		if err := w.WriteRecord(row.ToRecord()); err != nil {
			w.err = err
			return err
		}
	}
	return nil
}

func UnmarshalTypeLabel(record []string) TypeLabel {
	result := TypeLabel{}
	result.Name = record[0]
	if val, err := strconv.Atoi(record[1]); err != nil {
		log.Error(errors.Wrap(err, "Csv Error", "Could not convert int value"))
		log.ReportProblem("An error occured while unmarshalling data")
	} else {
		result.Label = val
	}
	return result
}

func (s TypeLabel) ToRecord() []string {
	record := make([]string, 2)
	record[0] = s.Name
	record[1] = fmt.Sprintf("%d", s.Label)
	return record
}

func MarshalTypeLabel(records []TypeLabel) [][]string {
	result := make([][]string, len(records))
	for i := range records {
		result[i] = records[i].ToRecord()
	}
	return result
}

func (r *Reader) ReadTypeLabelRecords() ([]TypeLabel, errors.Error) {
	defer r.Close()
	rows := make([]TypeLabel, 0, 8)
	for {
		if record, err := r.ReadRecord(); err != nil {
			if err.Is(errors.EOF) {
				return rows, nil
			}
			return nil, err
		} else {
			rows = append(rows, UnmarshalTypeLabel(record))
		}
	}
}

func (w *Writer) WriteTypeLabelRecords(rows []TypeLabel) errors.Error {
	defer w.Close()
	for _, row := range rows {
		if err := w.WriteRecord(row.ToRecord()); err != nil {
			w.err = err
			return err
		}
	}
	return nil
}

func UnmarshalIdealResult(record []string) IdealResult {
	result := IdealResult{}
	result.FilePath = record[0]
	result.FileType = record[1]
	result.Identifier = record[2]
	result.IdentifierType = record[3]
	if val, err := strconv.Atoi(record[4]); err != nil {
		log.Error(errors.Wrap(err, "Csv Error", "Could not convert int value"))
		log.ReportProblem("An error occured while unmarshalling data")
	} else {
		result.LineNumber = val
	}
	if val, err := strconv.Atoi(record[5]); err != nil {
		log.Error(errors.Wrap(err, "Csv Error", "Could not convert int value"))
		log.ReportProblem("An error occured while unmarshalling data")
	} else {
		result.ColumnNumber = val
	}
	result.IssueID = record[6]
	result.IssueAdditionalDetail = record[7]
	result.IssueCategory = record[8]
	result.IssueDetail = record[9]
	result.AnalysisDateTime = record[10]
	return result
}

func (s IdealResult) ToRecord() []string {
	record := make([]string, 11)
	record[0] = s.FilePath
	record[1] = s.FileType
	record[2] = s.Identifier
	record[3] = s.IdentifierType
	record[4] = fmt.Sprintf("%d", s.LineNumber)
	record[5] = fmt.Sprintf("%d", s.ColumnNumber)
	record[6] = s.IssueID
	record[7] = s.IssueAdditionalDetail
	record[8] = s.IssueCategory
	record[9] = s.IssueDetail
	record[10] = s.AnalysisDateTime
	return record
}

func MarshalIdealResult(records []IdealResult) [][]string {
	result := make([][]string, len(records))
	for i := range records {
		result[i] = records[i].ToRecord()
	}
	return result
}

func (r *Reader) ReadIdealResultRecords() ([]IdealResult, errors.Error) {
	defer r.Close()
	rows := make([]IdealResult, 0, 8)
	for {
		if record, err := r.ReadRecord(); err != nil {
			if err.Is(errors.EOF) {
				return rows, nil
			}
			return nil, err
		} else {
			rows = append(rows, UnmarshalIdealResult(record))
		}
	}
}

func (w *Writer) WriteIdealResultRecords(rows []IdealResult) errors.Error {
	defer w.Close()
	for _, row := range rows {
		if err := w.WriteRecord(row.ToRecord()); err != nil {
			w.err = err
			return err
		}
	}
	return nil
}
