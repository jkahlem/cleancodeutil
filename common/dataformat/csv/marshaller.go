/**
* THE CODE OF THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD NOT BE EDITED MANUALLY.
 */
package csv

import (
	"fmt"
	"returntypes-langserver/common/debug/errors"
	"strconv"
)

func UnmarshalMethod(record []string) (Method, errors.Error) {
	result := Method{}
	if len(record) < 8 {
		return result, errors.New(CsvErrorTitle, "Could not unmarshal to Method: Expected 8 fields but got record with %d fields.", len(record))
	}
	result.ClassName = record[0]
	result.ReturnType = record[1]
	result.MethodName = record[2]
	result.Parameters = SplitList(record[3])
	result.Labels = SplitList(record[4])
	result.Modifier = SplitList(record[5])
	result.ClassField = record[6]
	result.FilePath = record[7]
	return result, nil
}

func (s Method) ToRecord() []string {
	record := make([]string, 8)
	record[0] = s.ClassName
	record[1] = s.ReturnType
	record[2] = s.MethodName
	record[3] = MakeList(s.Parameters)
	record[4] = MakeList(s.Labels)
	record[5] = MakeList(s.Modifier)
	record[6] = s.ClassField
	record[7] = s.FilePath
	return record
}

func MarshalMethod(records []Method) [][]string {
	result := make([][]string, len(records))
	for i := range records {
		result[i] = records[i].ToRecord()
	}
	return result
}

func (r *Reader) ReadMethodRecords() ([]Method, errors.Error) {
	defer r.Close()
	rows := make([]Method, 0, 8)
	for {
		if record, err := r.ReadRecord(); err != nil {
			if err.Is(errors.EOF) {
				return rows, nil
			}
			return nil, err
		} else if unmarshalled, err := UnmarshalMethod(record); err != nil {
			return nil, err
		} else {
			rows = append(rows, unmarshalled)
		}
	}
}

func (w *Writer) WriteMethodRecords(rows []Method) errors.Error {
	defer w.Close()
	for _, row := range rows {
		if err := w.WriteRecord(row.ToRecord()); err != nil {
			w.err = err
			return err
		}
	}

	if w.destination.Flush(); w.destination.Error() != nil {
		return errors.Wrap(w.destination.Error(), CsvErrorTitle, "Could not write to csv output file")
	}
	return nil
}

func UnmarshalClass(record []string) (Class, errors.Error) {
	result := Class{}
	if len(record) < 2 {
		return result, errors.New(CsvErrorTitle, "Could not unmarshal to Class: Expected 2 fields but got record with %d fields.", len(record))
	}
	result.ClassName = record[0]
	result.Extends = SplitList(record[1])
	return result, nil
}

func (s Class) ToRecord() []string {
	record := make([]string, 2)
	record[0] = s.ClassName
	record[1] = MakeList(s.Extends)
	return record
}

func MarshalClass(records []Class) [][]string {
	result := make([][]string, len(records))
	for i := range records {
		result[i] = records[i].ToRecord()
	}
	return result
}

func (r *Reader) ReadClassRecords() ([]Class, errors.Error) {
	defer r.Close()
	rows := make([]Class, 0, 8)
	for {
		if record, err := r.ReadRecord(); err != nil {
			if err.Is(errors.EOF) {
				return rows, nil
			}
			return nil, err
		} else if unmarshalled, err := UnmarshalClass(record); err != nil {
			return nil, err
		} else {
			rows = append(rows, unmarshalled)
		}
	}
}

func (w *Writer) WriteClassRecords(rows []Class) errors.Error {
	defer w.Close()
	for _, row := range rows {
		if err := w.WriteRecord(row.ToRecord()); err != nil {
			w.err = err
			return err
		}
	}

	if w.destination.Flush(); w.destination.Error() != nil {
		return errors.Wrap(w.destination.Error(), CsvErrorTitle, "Could not write to csv output file")
	}
	return nil
}

func UnmarshalTypeConversion(record []string) (TypeConversion, errors.Error) {
	result := TypeConversion{}
	if len(record) < 2 {
		return result, errors.New(CsvErrorTitle, "Could not unmarshal to TypeConversion: Expected 2 fields but got record with %d fields.", len(record))
	}
	result.SourceType = record[0]
	result.DestinationType = record[1]
	return result, nil
}

func (s TypeConversion) ToRecord() []string {
	record := make([]string, 2)
	record[0] = s.SourceType
	record[1] = s.DestinationType
	return record
}

func MarshalTypeConversion(records []TypeConversion) [][]string {
	result := make([][]string, len(records))
	for i := range records {
		result[i] = records[i].ToRecord()
	}
	return result
}

func (r *Reader) ReadTypeConversionRecords() ([]TypeConversion, errors.Error) {
	defer r.Close()
	rows := make([]TypeConversion, 0, 8)
	for {
		if record, err := r.ReadRecord(); err != nil {
			if err.Is(errors.EOF) {
				return rows, nil
			}
			return nil, err
		} else if unmarshalled, err := UnmarshalTypeConversion(record); err != nil {
			return nil, err
		} else {
			rows = append(rows, unmarshalled)
		}
	}
}

func (w *Writer) WriteTypeConversionRecords(rows []TypeConversion) errors.Error {
	defer w.Close()
	for _, row := range rows {
		if err := w.WriteRecord(row.ToRecord()); err != nil {
			w.err = err
			return err
		}
	}

	if w.destination.Flush(); w.destination.Error() != nil {
		return errors.Wrap(w.destination.Error(), CsvErrorTitle, "Could not write to csv output file")
	}
	return nil
}

func UnmarshalReturnTypesDatasetRow(record []string) (ReturnTypesDatasetRow, errors.Error) {
	result := ReturnTypesDatasetRow{}
	if len(record) < 2 {
		return result, errors.New(CsvErrorTitle, "Could not unmarshal to ReturnTypesDatasetRow: Expected 2 fields but got record with %d fields.", len(record))
	}
	result.MethodName = record[0]
	if val, err := strconv.Atoi(record[1]); err != nil {
		return result, errors.Wrap(err, CsvErrorTitle, "Could not unmarshal to int: Expected integer value but got '%s'", record[1])
	} else {
		result.TypeLabel = val
	}
	return result, nil
}

func (s ReturnTypesDatasetRow) ToRecord() []string {
	record := make([]string, 2)
	record[0] = s.MethodName
	record[1] = fmt.Sprintf("%d", s.TypeLabel)
	return record
}

func MarshalReturnTypesDatasetRow(records []ReturnTypesDatasetRow) [][]string {
	result := make([][]string, len(records))
	for i := range records {
		result[i] = records[i].ToRecord()
	}
	return result
}

func (r *Reader) ReadReturnTypesDatasetRowRecords() ([]ReturnTypesDatasetRow, errors.Error) {
	defer r.Close()
	rows := make([]ReturnTypesDatasetRow, 0, 8)
	for {
		if record, err := r.ReadRecord(); err != nil {
			if err.Is(errors.EOF) {
				return rows, nil
			}
			return nil, err
		} else if unmarshalled, err := UnmarshalReturnTypesDatasetRow(record); err != nil {
			return nil, err
		} else {
			rows = append(rows, unmarshalled)
		}
	}
}

func (w *Writer) WriteReturnTypesDatasetRowRecords(rows []ReturnTypesDatasetRow) errors.Error {
	defer w.Close()
	for _, row := range rows {
		if err := w.WriteRecord(row.ToRecord()); err != nil {
			w.err = err
			return err
		}
	}

	if w.destination.Flush(); w.destination.Error() != nil {
		return errors.Wrap(w.destination.Error(), CsvErrorTitle, "Could not write to csv output file")
	}
	return nil
}

func UnmarshalMethodGenerationDatasetRow(record []string) (MethodGenerationDatasetRow, errors.Error) {
	result := MethodGenerationDatasetRow{}
	if len(record) < 6 {
		return result, errors.New(CsvErrorTitle, "Could not unmarshal to MethodGenerationDatasetRow: Expected 6 fields but got record with %d fields.", len(record))
	}
	result.ClassName = record[0]
	result.MethodName = record[1]
	result.ReturnType = record[2]
	if val, err := strconv.ParseBool(record[3]); err != nil {
		return result, errors.Wrap(err, CsvErrorTitle, "Could not unmarshal to bool: Expected boolean value, but got '%s'", record[3])
	} else {
		result.IsStatic = val
	}
	result.Parameters = SplitList(record[4])
	result.ContextTypes = SplitList(record[5])
	return result, nil
}

func (s MethodGenerationDatasetRow) ToRecord() []string {
	record := make([]string, 6)
	record[0] = s.ClassName
	record[1] = s.MethodName
	record[2] = s.ReturnType
	record[3] = strconv.FormatBool(s.IsStatic)
	record[4] = MakeList(s.Parameters)
	record[5] = MakeList(s.ContextTypes)
	return record
}

func MarshalMethodGenerationDatasetRow(records []MethodGenerationDatasetRow) [][]string {
	result := make([][]string, len(records))
	for i := range records {
		result[i] = records[i].ToRecord()
	}
	return result
}

func (r *Reader) ReadMethodGenerationDatasetRowRecords() ([]MethodGenerationDatasetRow, errors.Error) {
	defer r.Close()
	rows := make([]MethodGenerationDatasetRow, 0, 8)
	for {
		if record, err := r.ReadRecord(); err != nil {
			if err.Is(errors.EOF) {
				return rows, nil
			}
			return nil, err
		} else if unmarshalled, err := UnmarshalMethodGenerationDatasetRow(record); err != nil {
			return nil, err
		} else {
			rows = append(rows, unmarshalled)
		}
	}
}

func (w *Writer) WriteMethodGenerationDatasetRowRecords(rows []MethodGenerationDatasetRow) errors.Error {
	defer w.Close()
	for _, row := range rows {
		if err := w.WriteRecord(row.ToRecord()); err != nil {
			w.err = err
			return err
		}
	}

	if w.destination.Flush(); w.destination.Error() != nil {
		return errors.Wrap(w.destination.Error(), CsvErrorTitle, "Could not write to csv output file")
	}
	return nil
}

func UnmarshalTypeLabel(record []string) (TypeLabel, errors.Error) {
	result := TypeLabel{}
	if len(record) < 2 {
		return result, errors.New(CsvErrorTitle, "Could not unmarshal to TypeLabel: Expected 2 fields but got record with %d fields.", len(record))
	}
	result.Name = record[0]
	if val, err := strconv.Atoi(record[1]); err != nil {
		return result, errors.Wrap(err, CsvErrorTitle, "Could not unmarshal to int: Expected integer value but got '%s'", record[1])
	} else {
		result.Label = val
	}
	return result, nil
}

func (s TypeLabel) ToRecord() []string {
	record := make([]string, 2)
	record[0] = s.Name
	record[1] = fmt.Sprintf("%d", s.Label)
	return record
}

func MarshalTypeLabel(records []TypeLabel) [][]string {
	result := make([][]string, len(records))
	for i := range records {
		result[i] = records[i].ToRecord()
	}
	return result
}

func (r *Reader) ReadTypeLabelRecords() ([]TypeLabel, errors.Error) {
	defer r.Close()
	rows := make([]TypeLabel, 0, 8)
	for {
		if record, err := r.ReadRecord(); err != nil {
			if err.Is(errors.EOF) {
				return rows, nil
			}
			return nil, err
		} else if unmarshalled, err := UnmarshalTypeLabel(record); err != nil {
			return nil, err
		} else {
			rows = append(rows, unmarshalled)
		}
	}
}

func (w *Writer) WriteTypeLabelRecords(rows []TypeLabel) errors.Error {
	defer w.Close()
	for _, row := range rows {
		if err := w.WriteRecord(row.ToRecord()); err != nil {
			w.err = err
			return err
		}
	}

	if w.destination.Flush(); w.destination.Error() != nil {
		return errors.Wrap(w.destination.Error(), CsvErrorTitle, "Could not write to csv output file")
	}
	return nil
}

func UnmarshalFileContextTypes(record []string) (FileContextTypes, errors.Error) {
	result := FileContextTypes{}
	if len(record) < 2 {
		return result, errors.New(CsvErrorTitle, "Could not unmarshal to FileContextTypes: Expected 2 fields but got record with %d fields.", len(record))
	}
	result.FilePath = record[0]
	result.ContextTypes = SplitList(record[1])
	return result, nil
}

func (s FileContextTypes) ToRecord() []string {
	record := make([]string, 2)
	record[0] = s.FilePath
	record[1] = MakeList(s.ContextTypes)
	return record
}

func MarshalFileContextTypes(records []FileContextTypes) [][]string {
	result := make([][]string, len(records))
	for i := range records {
		result[i] = records[i].ToRecord()
	}
	return result
}

func (r *Reader) ReadFileContextTypesRecords() ([]FileContextTypes, errors.Error) {
	defer r.Close()
	rows := make([]FileContextTypes, 0, 8)
	for {
		if record, err := r.ReadRecord(); err != nil {
			if err.Is(errors.EOF) {
				return rows, nil
			}
			return nil, err
		} else if unmarshalled, err := UnmarshalFileContextTypes(record); err != nil {
			return nil, err
		} else {
			rows = append(rows, unmarshalled)
		}
	}
}

func (w *Writer) WriteFileContextTypesRecords(rows []FileContextTypes) errors.Error {
	defer w.Close()
	for _, row := range rows {
		if err := w.WriteRecord(row.ToRecord()); err != nil {
			w.err = err
			return err
		}
	}

	if w.destination.Flush(); w.destination.Error() != nil {
		return errors.Wrap(w.destination.Error(), CsvErrorTitle, "Could not write to csv output file")
	}
	return nil
}
