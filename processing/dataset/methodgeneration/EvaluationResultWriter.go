package methodgeneration

import (
	"returntypes-langserver/common/dataformat/csv"
	"returntypes-langserver/common/dataformat/excel"
	"returntypes-langserver/common/debug/errors"
	"returntypes-langserver/services/predictor"

	"github.com/xuri/excelize/v2"
)

type EvaluationResultWriter struct {
	path string
	file *excelize.File
}

func NewResultWriter(path string) *EvaluationResultWriter {
	return &EvaluationResultWriter{
		path: path,
	}
}

// Writes the examples to the result. exampleContexts are the configured examples as predictor.MethodContext objects.
// The generatedOutputs are the predictor.MethodValues which were generated by the predictor.
// len(exampleContexts) must equal len(generatedOutputs), so generatedOutputs[i] is the list of predicted values (suggestions) for
// the example at exampleContexts[i].
func (w *EvaluationResultWriter) WriteExamples(exampleContexts []predictor.MethodContext, generatedOutputs [][]predictor.MethodValues) errors.Error {
	if len(exampleContexts) != len(generatedOutputs) {
		return errors.New("Evaluation", "Could not write example output: The amount of generated values does not match the amount of examples.")
	}
	/*fmt.Fprintf(file, "%s:\n", examples[i])
	for _, value := range methodValues {
		//fmt.Fprintf(file, "- %s\n", value)
		fmt.Fprintf(file, "- %s\n", CreateMethodDefinition(examples[i], value))
	}*/
	w.file.NewSheet("Examples")
	cursor := excel.NewCursor(w.file, "Examples")
	cursor.WriteRowValues("Input", "Generated outputs")
	for i, example := range exampleContexts {
		cursor.Move(0, 1)
		cursor.WriteRowValues(example)
		cursor.Move(1, 1)
		for _, generatedValues := range generatedOutputs[i] {
			cursor.WriteRowValues(CreateMethodDefinition(example, generatedValues))
			cursor.Move(0, 1)
		}
		cursor.Move(-1, 0)
	}
	return cursor.Error()
}

func (w *EvaluationResultWriter) WriteMethods(methods []Method) errors.Error {
	w.checkFile()

	i := 0
	return excel.Stream().FromFunc(func() []string {
		if i > len(methods) {
			return nil
		}
		record := w.toMethodRecord(methods[i])
		i++
		return record
	}).ToSheet(w.file, "Generated methods")
}

func (w *EvaluationResultWriter) toMethodRecord(method Method) []string {
	return []string{method.Name, method.ExpectedDefinition.String(), method.GeneratedDefinition.String()}
}

func (w *EvaluationResultWriter) WriteIdealResults(records []csv.IdealResult) errors.Error {
	w.checkFile()

	i := 0
	return excel.Stream().FromFunc(func() []string {
		if i > len(records) {
			return nil
		}
		record := records[i].ToRecord()
		i++
		return record
	}).ToSheet(w.file, "IDEAL Results")
}

func (w *EvaluationResultWriter) WriteScores(evalset *EvaluationSet) errors.Error {
	if evalset == nil {
		return errors.New("Evaluation", "Could not create evaluation result output")
	}

	sheet := "Set - " + evalset.Name
	w.file.NewSheet(sheet)
	cursor := excel.NewCursor(w.file, sheet)

	for _, rater := range evalset.Rater {
		cursor.WriteRowValues("Rating method:", rater.Name())
		cursor.Move(0, 1)
		result := rater.Result()
		cursor.WriteStringValues(result)
		cursor.Move(0, len(result)+1)
	}

	if err := cursor.Error(); err != nil {
		return err
	}

	for _, set := range evalset.Subsets {
		if err := w.WriteScores(&set); err != nil {
			return err
		}
	}
	return nil
}

func (w *EvaluationResultWriter) checkFile() {
	if w.file == nil {
		w.file = excelize.NewFile()
		w.file.Path = w.path
	}
}

func (w *EvaluationResultWriter) Close() errors.Error {
	if w.file == nil {
		return nil
	}
	return errors.Wrap(w.file.Save(), "Evaluation", "Could not save output file")
}
