/**
* THE CODE OF THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD NOT BE EDITED MANUALLY.
 */
package languageserver

import (
	"io"
	"reflect"
	"sync"

	"returntypes-langserver/common/debug/errors"
	"returntypes-langserver/common/transfer/rpc"
	"returntypes-langserver/languageserver/diagnostics"
	"returntypes-langserver/languageserver/lsp"
	"returntypes-langserver/languageserver/workspace"
)

type ProxyFacade struct {
	Proxy Proxy `rpcproxy:"true"`
}

func (p *ProxyFacade) PublishDiagnostics(uri lsp.DocumentURI, diagnostics []lsp.Diagnostic, version int) {
	if err := p.validate(p.Proxy.PublishDiagnostics); err != nil {
		return
	}
	p.Proxy.PublishDiagnostics(uri, diagnostics, version)
}

func (p *ProxyFacade) ShowMessage(msgType lsp.MessageType, message string) {
	if err := p.validate(p.Proxy.ShowMessage); err != nil {
		return
	}
	p.Proxy.ShowMessage(msgType, message)
}

func (p *ProxyFacade) ShowMessageRequest(msgType lsp.MessageType, message string, actions []lsp.MessageActionItem) (lsp.MessageActionItem, errors.Error) {
	if err := p.validate(p.Proxy.ShowMessageRequest); err != nil {
		return lsp.MessageActionItem{}, err
	}
	return p.Proxy.ShowMessageRequest(msgType, message, actions)
}

func (p *ProxyFacade) LogMessage(msgType lsp.MessageType, message string) {
	if err := p.validate(p.Proxy.LogMessage); err != nil {
		return
	}
	p.Proxy.LogMessage(msgType, message)
}

func (p *ProxyFacade) GetConfiguration(items []lsp.ConfigurationItem) ([]interface{}, errors.Error) {
	if err := p.validate(p.Proxy.GetConfiguration); err != nil {
		return nil, err
	}
	return p.Proxy.GetConfiguration(items)
}

func (p *ProxyFacade) RegisterCapability(registrations []lsp.Registration) errors.Error {
	if err := p.validate(p.Proxy.RegisterCapability); err != nil {
		return err
	}
	return p.Proxy.RegisterCapability(registrations)
}

func (p *ProxyFacade) validate(fn interface{}) errors.Error {
	fnVal := reflect.ValueOf(fn)
	if !fnVal.IsValid() || fnVal.IsZero() {
		return errors.New("RPC Error", "Interface function does not exist")
	}
	return nil
}

var singleton *languageServer
var singletonMutex sync.Mutex

func getSingleton() *languageServer {
	singletonMutex.Lock()
	defer singletonMutex.Unlock()

	if singleton == nil {
		singleton = createSingleton()
	}
	return singleton
}

func createSingleton() *languageServer {

	return &languageServer{}
}

func Configuration() *ServerConfiguration {
	return getSingleton().Configuration()
}

func setClientCapabilities(clientCapabilities lsp.ClientCapabilities) {
	getSingleton().setClientCapabilities(clientCapabilities)
}

// Starts the language server.
func Startup() {
	getSingleton().Startup()
}

// Create virtual workspaces using the given workspace folders.
func createVirtualWorkspaces(workspaces []lsp.WorkspaceFolder) {
	getSingleton().createVirtualWorkspaces(workspaces)
}

// Create a virtual workspace using the given workspace folder.
func createVirtualWorkspace(workspace lsp.WorkspaceFolder) errors.Error {
	return getSingleton().createVirtualWorkspace(workspace)
}

// Adds a file on the given path into the virtual workspace if it does not exist there already.
func AddFileIfNotExists(path string) {
	getSingleton().AddFileIfNotExists(path)
}

// Reloads the file on the given path in all virtual workspaces containing it.
func ReloadFile(path string) {
	getSingleton().ReloadFile(path)
}

// Renames the file on the given path in all virtual workspaces containing it.
func RenameFile(oldPath string, newPath string) {
	getSingleton().RenameFile(oldPath, newPath)
}

// Deletes the file on the given path in all virtual workspaces containing it.
func DeleteFile(path string) {
	getSingleton().DeleteFile(path)
}

// Updates the diagnostics of the given file in all workspaces containing it.
func UpdateDiagnostics(path string, changes []lsp.TextDocumentContentChangeEvent) {
	getSingleton().UpdateDiagnostics(path, changes)
}

// Refreshes the diagnostics for all files.
func RefreshDiagnosticsForAllFiles() {
	getSingleton().RefreshDiagnosticsForAllFiles()
}

// Refrehses the diagnostics for all files in a virtual workspace.
func refreshDiagnosticsForAllFilesInWorkspace(ws *workspace.Workspace) {
	getSingleton().refreshDiagnosticsForAllFilesInWorkspace(ws)
}

// Refreshes the diagnostics for a given file.
func RefreshDiagnosticsForFile(path string) {
	getSingleton().RefreshDiagnosticsForFile(path)
}

// Refreshes the diagnostics for a file in a virtual workspace.
func refreshDiagnosticsForFile(ws *workspace.Workspace, file *workspace.FileWrapper) errors.Error {
	return getSingleton().refreshDiagnosticsForFile(ws, file)
}

// Returns a diagnostics creator.
func getDiagnosticsCreator() *diagnostics.Creator {
	return getSingleton().getDiagnosticsCreator()
}

// Publishes diagnostics to the client.
func PublishDiagnostics(path string, diagnostics []lsp.Diagnostic, version int) {
	getSingleton().PublishDiagnostics(path, diagnostics, version)
}

// Returns true if the client supports versioning of diagnostics.
func isClientSupportingDiagnosticVersions() bool {
	return getSingleton().isClientSupportingDiagnosticVersions()
}

// Returns true if the client supports the textDocument/publishDiagnostics method.
func isClientSupportingDiagnostics() bool {
	return getSingleton().isClientSupportingDiagnostics()
}

// Shows a message to the user in the IDE.
func ShowMessage(msgType lsp.MessageType, message string) {
	getSingleton().ShowMessage(msgType, message)
}

// Makes a request to the user with possible actions (appears for example as buttons the user can click)
func ShowMessageRequest(msgType lsp.MessageType, message string, actions []Action) {
	getSingleton().ShowMessageRequest(msgType, message, actions)
}

// Logs a message to the IDE.
func LogMessage(msgType lsp.MessageType, message string) {
	getSingleton().LogMessage(msgType, message)
}

// Recovers the predictor connection.
func RecoverPredictor() {
	getSingleton().RecoverPredictor()
}

// Loads the extension configuration of the IDE.
func LoadConfiguration() chan errors.Error {
	return getSingleton().LoadConfiguration()
}

// Loads the extension configuration of the IDE.
func loadConfiguration(items ...string) errors.Error {
	return getSingleton().loadConfiguration(items...)
}

// Registers workspace/didChangeConfiguration for the extension's configuration sections.
// This capability needs to be registered explicitly, otherwise there will be no notifications.
func RegisterDidChangeWorkspaceCapability() chan errors.Error {
	return getSingleton().RegisterDidChangeWorkspaceCapability()
}

// Registers a capability.
func RegisterCapability(registrations ...lsp.Registration) chan errors.Error {
	return getSingleton().RegisterCapability(registrations...)
}

var interfaceSingleton rpc.Interface
var interfaceMutex sync.Mutex

// Returns a proxy which can be used to communicate with the client.
func remote() *ProxyFacade {
	if ifc := getInterface(); ifc != nil && ifc.ProxyFacade() != nil {
		if facade, ok := ifc.ProxyFacade().(*ProxyFacade); ok {
			return facade
		}
	}
	return &ProxyFacade{}
}

// Returns the service connection
func serviceConnection() io.ReadWriter {
	if getInterface() != nil {
		return getInterface().Connection()
	}
	return nil
}

// Returns the used service interface
func getInterface() rpc.Interface {
	interfaceMutex.Lock()
	defer interfaceMutex.Unlock()

	if interfaceSingleton == nil {
		serviceConfig := serviceConfiguration()
		if ifc, err := rpc.BuildInterfaceFromServiceConfiguration(serviceConfig, &ProxyFacade{}); err != nil {
			if serviceConfig.OnInterfaceCreationError != nil {
				serviceConfig.OnInterfaceCreationError(err)
			}
		} else {
			interfaceSingleton = ifc
		}
	}
	return interfaceSingleton
}
