/**
* THE CODE OF THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD NOT BE EDITED MANUALLY.
 */
package predictor

import (
	"io"
	"reflect"
	"sync"

	"returntypes-langserver/common/debug/errors"
	"returntypes-langserver/common/transfer/rpc"
)

type ProxyFacade struct {
	Proxy Proxy `rpcproxy:"true"`
}

// Predicts the return types of the given methods (which are in a "predictable" format, so in the sentence format)
// The return types are in the same order the method names were sent.
func (p *ProxyFacade) Predict(predictionData []string, targetModel SupportedModels) ([]string, errors.Error) {
	if err := p.validate(p.Proxy.Predict); err != nil {
		return nil, err
	}
	return p.Proxy.Predict(predictionData, targetModel)
}

// Trains the predictor and returns the evaluation result if finished.
func (p *ProxyFacade) Train(trainingSet string, evaluationSet string, additional string, targetModel SupportedModels) (Evaluation, errors.Error) {
	if err := p.validate(p.Proxy.Train); err != nil {
		return Evaluation{}, err
	}
	return p.Proxy.Train(trainingSet, evaluationSet, additional, targetModel)
}

func (p *ProxyFacade) PredictNew(predictionData []MethodContext, options Options) ([]MethodValues, errors.Error) {
	if err := p.validate(p.Proxy.PredictNew); err != nil {
		return nil, err
	}
	return p.Proxy.PredictNew(predictionData, options)
}

func (p *ProxyFacade) TrainNew(trainData []Method, options Options) errors.Error {
	if err := p.validate(p.Proxy.TrainNew); err != nil {
		return err
	}
	return p.Proxy.TrainNew(trainData, options)
}

func (p *ProxyFacade) Evaluate(evaluationData []Method, options Options) (Evaluation, errors.Error) {
	if err := p.validate(p.Proxy.Evaluate); err != nil {
		return Evaluation{}, err
	}
	return p.Proxy.Evaluate(evaluationData, options)
}

func (p *ProxyFacade) validate(fn interface{}) errors.Error {
	fnVal := reflect.ValueOf(fn)
	if !fnVal.IsValid() || fnVal.IsZero() {
		return errors.New("RPC Error", "Interface function does not exist")
	}
	return nil
}

var interfaceSingleton rpc.Interface
var interfaceMutex sync.Mutex

// Returns a proxy which can be used to communicate with the client.
func remote() *ProxyFacade {
	if ifc := getInterface(); ifc != nil && ifc.ProxyFacade() != nil {
		if facade, ok := ifc.ProxyFacade().(*ProxyFacade); ok {
			return facade
		}
	}
	return &ProxyFacade{}
}

// Returns the service connection
func serviceConnection() io.ReadWriter {
	if getInterface() != nil {
		return getInterface().Connection()
	}
	return nil
}

// Returns the used service interface
func getInterface() rpc.Interface {
	interfaceMutex.Lock()
	defer interfaceMutex.Unlock()

	if interfaceSingleton == nil {
		serviceConfig := serviceConfiguration()
		if ifc, err := rpc.BuildInterfaceFromServiceConfiguration(serviceConfig, &ProxyFacade{}); err != nil {
			if serviceConfig.OnInterfaceCreationError != nil {
				serviceConfig.OnInterfaceCreationError(err)
			}
		} else {
			interfaceSingleton = ifc
		}
	}
	return interfaceSingleton
}
