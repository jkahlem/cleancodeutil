/**
* THE CODE OF THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD NOT BE EDITED MANUALLY.
 */
package predictor

import (
	"io"
	"reflect"
	"sync"

	"returntypes-langserver/common/debug/errors"
	"returntypes-langserver/common/transfer/rpc"
)

type ProxyFacade struct {
	Proxy Proxy `rpcproxy:"true"`
}

func (p *ProxyFacade) Predict(predictionData []MethodContext, options Options) ([]MethodValues, errors.Error) {
	if err := p.validate(p.Proxy.Predict); err != nil {
		var empty0 []MethodValues
		return empty0, err
	}
	return p.Proxy.Predict(predictionData, options)
}

func (p *ProxyFacade) PredictMultiple(predictionData []MethodContext, options Options) ([][]MethodValues, errors.Error) {
	if err := p.validate(p.Proxy.PredictMultiple); err != nil {
		var empty0 [][]MethodValues
		return empty0, err
	}
	return p.Proxy.PredictMultiple(predictionData, options)
}

func (p *ProxyFacade) Train(trainData []Method, options Options, continueTraining bool) errors.Error {
	if err := p.validate(p.Proxy.Train); err != nil {
		return err
	}
	return p.Proxy.Train(trainData, options, continueTraining)
}

func (p *ProxyFacade) Evaluate(evaluationData []Method, options Options) (Evaluation, errors.Error) {
	if err := p.validate(p.Proxy.Evaluate); err != nil {
		var empty0 Evaluation
		return empty0, err
	}
	return p.Proxy.Evaluate(evaluationData, options)
}

func (p *ProxyFacade) Exists(options Options) (bool, errors.Error) {
	if err := p.validate(p.Proxy.Exists); err != nil {
		var empty0 bool
		return empty0, err
	}
	return p.Proxy.Exists(options)
}

func (p *ProxyFacade) GetCheckpoints(options Options) ([]string, errors.Error) {
	if err := p.validate(p.Proxy.GetCheckpoints); err != nil {
		var empty0 []string
		return empty0, err
	}
	return p.Proxy.GetCheckpoints(options)
}

func (p *ProxyFacade) GetModels(modelType SupportedModels) ([]Model, errors.Error) {
	if err := p.validate(p.Proxy.GetModels); err != nil {
		var empty0 []Model
		return empty0, err
	}
	return p.Proxy.GetModels(modelType)
}

func (p *ProxyFacade) validate(fn interface{}) errors.Error {
	fnVal := reflect.ValueOf(fn)
	if !fnVal.IsValid() || fnVal.IsZero() {
		return errors.New("RPC Error", "Interface function does not exist")
	}
	return nil
}

var interfaceSingleton rpc.Interface
var interfaceMutex sync.Mutex

// Returns a proxy which can be used to communicate with the client.
func remote() *ProxyFacade {
	if ifc := getInterface(); ifc != nil && ifc.ProxyFacade() != nil {
		if facade, ok := ifc.ProxyFacade().(*ProxyFacade); ok {
			return facade
		}
	}
	return &ProxyFacade{}
}

// Returns the service connection
func serviceConnection() io.ReadWriter {
	if getInterface() != nil {
		return getInterface().Connection()
	}
	return nil
}

// Returns the used service interface
func getInterface() rpc.Interface {
	interfaceMutex.Lock()
	defer interfaceMutex.Unlock()

	if interfaceSingleton == nil {
		serviceConfig := serviceConfiguration()
		if ifc, err := rpc.BuildInterfaceFromServiceConfiguration(serviceConfig, &ProxyFacade{}); err != nil {
			if serviceConfig.OnInterfaceCreationError != nil {
				serviceConfig.OnInterfaceCreationError(err)
			}
		} else {
			interfaceSingleton = ifc
		}
	}
	return interfaceSingleton
}
