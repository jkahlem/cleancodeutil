/**
* THE CODE OF THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD NOT BE EDITED MANUALLY.
 */
package predictor

import (
	"io"
	"reflect"
	"sync"

	"returntypes-langserver/common/debug/errors"
	"returntypes-langserver/common/debug/log"
	"returntypes-langserver/common/transfer/rpc"
)

type ProxyFacade struct {
	Proxy Proxy `rpcproxy:"true"`
}

// Predicts the return types of the given methods (which are in a "predictable" format, so in the sentence format)
// The return types are in the same order the method names were sent.
func (p *ProxyFacade) Predict(predictionData []string, targetModel SupportedModels) ([]string, errors.Error) {
	if err := p.validate(p.Proxy.Predict); err != nil {
		return nil, err
	}
	return p.Proxy.Predict(predictionData, targetModel)
}

// Trains the predictor and returns the evaluation result if finished.
func (p *ProxyFacade) Train(trainingSet string, evaluationSet string, additional string, targetModel SupportedModels) (Evaluation, errors.Error) {
	if err := p.validate(p.Proxy.Train); err != nil {
		return Evaluation{}, err
	}
	return p.Proxy.Train(trainingSet, evaluationSet, additional, targetModel)
}

func (p *ProxyFacade) validate(fn interface{}) errors.Error {
	fnVal := reflect.ValueOf(fn)
	if !fnVal.IsValid() || fnVal.IsZero() {
		return errors.New("RPC Error", "Interface function does not exist")
	}
	return nil
}

var singleton Predictor
var singletonMutex sync.Mutex

func getSingleton() Predictor {
	singletonMutex.Lock()
	defer singletonMutex.Unlock()

	if singleton == nil {
		singleton = createSingleton()
	}
	return singleton
}

func createSingleton() Predictor {

	if serviceConfiguration().UseMock {
		log.Info("Setup Predictor service using mock...\n")
		return &mock{}
	}

	return &predictor{}
}

// Makes predictions for the methods in the map and sets the types as their value.
func PredictReturnTypesToMap(mapping MethodTypeMap) errors.Error {
	return getSingleton().PredictReturnTypesToMap(mapping)
}

// Predicts the expected return type for the given method names. Returns a list of expected return types in the exact order
// the method names were passed.
func PredictReturnTypes(methodNames []PredictableMethodName) ([]string, errors.Error) {
	return getSingleton().PredictReturnTypes(methodNames)
}

// Generates the remained part of a method by it's method name
func GenerateMethods(methodNames []PredictableMethodName) ([]string, errors.Error) {
	return getSingleton().GenerateMethods(methodNames)
}

// Starts the training and evaluation process. Returns the evaluation result if finished.
func TrainReturnTypes(labels [][]string, trainingSet [][]string, evaluationSet [][]string) (Evaluation, errors.Error) {
	return getSingleton().TrainReturnTypes(labels, trainingSet, evaluationSet)
}

// Starts the training and evaluation process. Returns the evaluation result if finished.
func TrainMethods(trainingSet [][]string, evaluationSet [][]string) (Evaluation, errors.Error) {
	return getSingleton().TrainMethods(trainingSet, evaluationSet)
}

var interfaceSingleton rpc.Interface
var interfaceMutex sync.Mutex

// Returns a proxy which can be used to communicate with the client.
func remote() *ProxyFacade {
	if ifc := getInterface(); ifc != nil && ifc.ProxyFacade() != nil {
		if facade, ok := ifc.ProxyFacade().(*ProxyFacade); ok {
			return facade
		}
	}
	return &ProxyFacade{}
}

// Returns the service connection
func serviceConnection() io.ReadWriter {
	if getInterface() != nil {
		return getInterface().Connection()
	}
	return nil
}

// Returns the used service interface
func getInterface() rpc.Interface {
	interfaceMutex.Lock()
	defer interfaceMutex.Unlock()

	if interfaceSingleton == nil {
		serviceConfig := serviceConfiguration()
		if ifc, err := rpc.BuildInterfaceFromServiceConfiguration(serviceConfig, &ProxyFacade{}); err != nil {
			if serviceConfig.OnInterfaceCreationError != nil {
				serviceConfig.OnInterfaceCreationError(err)
			}
		} else {
			interfaceSingleton = ifc
		}
	}
	return interfaceSingleton
}
