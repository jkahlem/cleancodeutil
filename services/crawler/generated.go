/**
* THE CODE OF THIS FILE IS AUTOMATICALLY GENERATED AND SHOULD NOT BE EDITED MANUALLY.
 */
package crawler

import (
	"io"
	"reflect"
	"sync"

	"returntypes-langserver/common/code/java"
	"returntypes-langserver/common/debug/errors"
	"returntypes-langserver/common/transfer/rpc"
)

type ProxyFacade struct {
	Proxy Proxy `rpcproxy:"true"`
}

// Gets the content of a code file as a XML object
func (p *ProxyFacade) GetFileContent(path string, options Options) (string, errors.Error) {
	if err := p.validate(p.Proxy.GetFileContent); err != nil {
		return "", err
	}
	return p.Proxy.GetFileContent(path, options)
}

// Gets the content of all code files in a directory as one xml object
func (p *ProxyFacade) GetDirectoryContents(path string, options Options) (string, errors.Error) {
	if err := p.validate(p.Proxy.GetDirectoryContents); err != nil {
		return "", err
	}
	return p.Proxy.GetDirectoryContents(path, options)
}

func (p *ProxyFacade) validate(fn interface{}) errors.Error {
	fnVal := reflect.ValueOf(fn)
	if !fnVal.IsValid() || fnVal.IsZero() {
		return errors.New("RPC Error", "Interface function does not exist")
	}
	return nil
}

var singleton *crawler
var singletonMutex sync.Mutex

func getSingleton() *crawler {
	singletonMutex.Lock()
	defer singletonMutex.Unlock()

	if singleton == nil {
		singleton = createSingleton()
	}
	return singleton
}

func createSingleton() *crawler {

	return &crawler{}
}

// Gets the content of one java file.
func GetCodeElements(path string, options Options) (java.FileContainer, errors.Error) {
	return getSingleton().GetCodeElements(path, options)
}

// Gets the content of all java files in the specified directory.
func GetCodeElementsOfDirectory(path string, options Options) (java.FileContainer, errors.Error) {
	return getSingleton().GetCodeElementsOfDirectory(path, options)
}

// Gets the content of all java files in the specified directory.
func GetRawCodeElementsOfDirectory(path string, options Options) (string, errors.Error) {
	return getSingleton().GetRawCodeElementsOfDirectory(path, options)
}

func decodeXmlContent(xml string) (java.FileContainer, errors.Error) {
	return getSingleton().decodeXmlContent(xml)
}

var interfaceSingleton rpc.Interface
var interfaceMutex sync.Mutex

// Returns a proxy which can be used to communicate with the client.
func remote() *ProxyFacade {
	if ifc := getInterface(); ifc != nil && ifc.ProxyFacade() != nil {
		if facade, ok := ifc.ProxyFacade().(*ProxyFacade); ok {
			return facade
		}
	}
	return &ProxyFacade{}
}

// Returns the service connection
func serviceConnection() io.ReadWriter {
	if getInterface() != nil {
		return getInterface().Connection()
	}
	return nil
}

// Returns the used service interface
func getInterface() rpc.Interface {
	interfaceMutex.Lock()
	defer interfaceMutex.Unlock()

	if interfaceSingleton == nil {
		serviceConfig := serviceConfiguration()
		if ifc, err := rpc.BuildInterfaceFromServiceConfiguration(serviceConfig, &ProxyFacade{}); err != nil {
			if serviceConfig.OnInterfaceCreationError != nil {
				serviceConfig.OnInterfaceCreationError(err)
			}
		} else {
			interfaceSingleton = ifc
		}
	}
	return interfaceSingleton
}
